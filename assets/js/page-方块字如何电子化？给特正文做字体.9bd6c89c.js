(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{671:function(v,_,t){"use strict";t.r(_);var s=t(1),e=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"方块字如何电子化-给特正文做字体"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方块字如何电子化-给特正文做字体"}},[v._v("#")]),v._v(" 方块字如何电子化？给"),_("u",[v._v("特正文")]),v._v("做字体")]),v._v(" "),_("p",[_("u",[v._v("特正文")]),v._v("是"),_("u",[v._v("帜和语")]),v._v("的三种官方文字中优先级最高的一种。然而，他是一种方块字，电子化困难，一直依赖手写，使用很受限。近期我终于牺牲了一些优雅性，把"),_("u",[v._v("特正文")]),v._v("字体搞出来了。下面讲讲流程。")]),v._v(" "),_("h2",{attrs:{id:"第一步-确定unicode编码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一步-确定unicode编码"}},[v._v("#")]),v._v(" 第一步：确定Unicode编码")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("推荐方案")]),v._v(" "),_("p",[v._v("一个编码对应一个"),_("u",[v._v("特正")]),v._v("字，随机顺序，维护一个码表文件就行了")])]),v._v(" "),_("p",[_("u",[v._v("特正文")]),v._v("是一种方块表音文字，造字逻辑有点类似"),_("u",[v._v("谚文")]),v._v("。")]),v._v(" "),_("p",[v._v("我一开始是想利用OpenType特性实现字母自组装成方块字的，然而……水平不够，做不出来。")]),v._v(" "),_("p",[v._v("后来想按一定规律去编码。然而，不像"),_("u",[v._v("谚文")]),v._v("字的总数量有限，"),_("u",[v._v("特正字")]),v._v("理论上是无限多的（无限堆词缀、很长的复辅音等等）。到底要编到多少？")]),v._v(" "),_("p",[v._v("最后还是决定按词典顺序来编码，词典没收录的变形、变位、派生词等就随机放后面。")]),v._v(" "),_("h2",{attrs:{id:"第二步-制作字形"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二步-制作字形"}},[v._v("#")]),v._v(" 第二步：制作字形")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("推荐方案")]),v._v(" "),_("p",[v._v("用平板笔记软件批量手写")])]),v._v(" "),_("p",[v._v("既选择了整字编码，制作字形就是最难的一步。如果想做的质量高一些，应该使用电脑上的矢量图编辑软件（如Inkscape、Adobe Illustrator等），然而这个对我来说难度有点高，且工作量太大。")]),v._v(" "),_("p",[v._v("于是退而求其次。先制作一个8×16的田格纸作背景，使用平板电脑上的笔记软件（享做笔记）手写。写完一批（128个字）就导出为pdf即可。")]),v._v(" "),_("h2",{attrs:{id:"第三步-切割字形"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三步-切割字形"}},[v._v("#")]),v._v(" 第三步：切割字形")]),v._v(" "),_("p",[v._v("上一步已经导出了一个写有128个字的pdf。那么，在电脑上用Inkscape去掉田格背景，把字形粘贴进FontForge就可以了。")]),v._v(" "),_("p",[v._v("然而这样工作量还是太大——128个字在同一个文件里，难道要一个字一个字地复制粘贴进FontForge吗？那必不行，一共一千多字呢。")]),v._v(" "),_("p",[v._v("于是我想到先自动切割然后批量导入。但是我没找到能自动切割矢量图（"),_("code",[v._v(".svg")]),v._v("或"),_("code",[v._v(".pdf")]),v._v("）的程序，而FontForge只收矢量图。")]),v._v(" "),_("p",[v._v("没办法，我选择了这个很不优雅的办法：先把整张矢量图"),_("code",[v._v(".svg")]),v._v("转为整张位图"),_("code",[v._v(".png")]),v._v("，切割位图，切得的位图重新矢量化成"),_("code",[v._v(".svg")]),v._v("。")]),v._v(" "),_("ol",[_("li",[v._v("整张"),_("code",[v._v(".svg")]),v._v("转"),_("code",[v._v(".png")]),v._v("：直接用Inkscape导出就行")]),v._v(" "),_("li",[v._v("切割位图：我自己写了个Python脚本来自动切割并重命名，见附录")]),v._v(" "),_("li",[_("code",[v._v(".png")]),v._v("转"),_("code",[v._v(".svg")]),v._v("：我找到了vectorizer.com来完成这一步。他的缺点是一次性只能转20张图，不过也算勉强够用了。")])]),v._v(" "),_("h2",{attrs:{id:"第四步-导入字形"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第四步-导入字形"}},[v._v("#")]),v._v(" 第四步：导入字形")]),v._v(" "),_("p",[v._v("有了前面的准备，这步就不难了。FontForge支持Python，写个Python脚本就能把刚生产出的一系列字形svg自动导入了，见附录。我暂时没研究出来用脚本改字形边界和宽度，好在这俩操作在FontForge的界面里也不难完成。")]),v._v(" "),_("h2",{attrs:{id:"第五步-调整字重"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第五步-调整字重"}},[v._v("#")]),v._v(" 第五步：调整字重")]),v._v(" "),_("p",[v._v("前面的步骤埋了个雷：字太细。于是用FontForge的Elements > Styles菜单中的Change Weight来批量自动加粗。")]),v._v(" "),_("p",[v._v("这又有个坑：很多字形无法加粗，会卡死。解决方法就是把FontForge的各种自动优化都用一遍，还有不行的字形手动处理一下，就可以加粗了。")]),v._v(" "),_("p",[v._v("加粗以后出了很多毛刺和空洞……总之建议第一步写字的时候就按合适的字重来写罢，到了这步就只能手动处理一下了。")])])}),[],!1,null,null,null);_.default=e.exports}}]);